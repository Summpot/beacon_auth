import org.gradle.jvm.JvmLibrary
import org.gradle.api.artifacts.result.ResolvedArtifactResult
import org.gradle.language.base.artifact.SourcesArtifact
import org.gradle.api.file.DuplicatesStrategy

plugins {
    id("dev.architectury.loom") version "1.13-SNAPSHOT" apply false
    id("architectury-plugin") version "3.4-SNAPSHOT"
    id("com.gradleup.shadow") version "8.3.6" apply false
    kotlin("jvm") version "2.2.21" apply false
}

allprojects {
    group = project.property("maven_group").toString()
    version = project.property("mod_version").toString()
}

subprojects {
    apply(plugin = "dev.architectury.loom")
    apply(plugin = "architectury-plugin")
    apply(plugin = "maven-publish")
    apply(plugin = "org.jetbrains.kotlin.jvm")

    extensions.configure<BasePluginExtension> {
        archivesName.set("${rootProject.property("archives_name")}-${project.name}")
    }

    repositories {
        mavenCentral()
        maven {
            name = "NeoForged"
            url = uri("https://maven.neoforged.net/releases")
        }
        maven {
            name = "Fuzs Mod Resources"
            url = uri("https://raw.githubusercontent.com/Fuzss/modresources/main/maven/")
        }
    }

    configure<net.fabricmc.loom.api.LoomGradleExtensionAPI> {
        silentMojangMappingsLicense()
    }

    configure<JavaPluginExtension> {
        withSourcesJar()
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    tasks.withType<JavaCompile> {
        options.release.set(21)
    }

    tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
        }
    }

    tasks.register<Copy>("unpackSources") {
        group = "development"
        description = "Unpacks the sources generated by the decompiler task."

        // 1. 动态寻找真正的反编译任务
        // Loom 可能使用 Vineflower 或 Fernflower，或者其他名称
        // 我们查找所有以 'genSourcesWith' 开头的任务，通常只有一个
        val decompileTask = tasks.withType<Task>()
            .find { it.name.startsWith("genSourcesWith") }
            ?: tasks.findByName("genSources")

        if (decompileTask != null) {
            dependsOn(decompileTask)

            // 2. 将其输出作为输入
            inputs.files(decompileTask.outputs.files)

            // 3. 打印调试信息：让我们看看它到底找到了什么文件
            doFirst {
                val files = decompileTask.outputs.files.files
                println(">>> [unpackSources] Found source files in task '${decompileTask.name}':")
                files.forEach { println("    - ${it.absolutePath}") }

                if (files.isEmpty()) {
                    println(">>> [WARNING] No output files found for task '${decompileTask.name}'!")
                }
            }

            // 4. 获取 Jar 包
            val sourceTrees = provider {
                decompileTask.outputs.files
                    .filter { it.name.endsWith(".jar") }
                    .map { zipTree(it) }
            }

            from(sourceTrees) {
                exclude("META-INF/**", "assets/**", "data/**", "*.json", "*.png", "*.class")
            }
        } else {
            enabled = false
        }

        into(layout.buildDirectory.dir("minecraft-sources"))
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
    }

    configure<PublishingExtension> {
        publications {
            create<MavenPublication>("mavenJava") {
                artifactId = extensions.getByType<BasePluginExtension>().archivesName.get()
                from(components["java"])
            }
        }
    }
}